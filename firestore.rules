/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for tasks and projects.
 *
 * Data Structure:
 * - /artifacts/{appId}/users/{userId}/tasks/{taskId}: Stores individual tasks owned by a specific user within a specific application.
 * - /artifacts/{appId}: Top-level collection grouping data by application ID.
 *
 * Key Security Decisions:
 * - User data is strictly segregated by path; only the authenticated user can access their own tasks.
 * - Listing tasks is allowed only for the owner of the tasks.
 * - The rules are designed to work with single tenant.
 *
 * Authorization Denormalization:
 * - Not required, ownership is derived from the data structure path.
 *
 * Structural Segregation:
 * - Private task data is stored under /users/{userId}, separate from any potentially public data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if the user is the owner of the resource based on the userId
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Helper function to check if the user is the owner of the existing resource
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Allows access to a specific task if the user is the owner.
     * @path /artifacts/{appId}/users/{userId}/tasks/{taskId}
     * @allow (get) User A can read their own task: auth.uid == "userA", path == "/artifacts/app1/users/userA/tasks/task1"
     * @allow (create) User A can create a task under their user id: auth.uid == "userA", path == "/artifacts/app1/users/userA/tasks/task1", request.resource.data.id == "userA"
     * @allow (update) User A can update their own task: auth.uid == "userA", path == "/artifacts/app1/users/userA/tasks/task1"
     * @allow (delete) User A can delete their own task: auth.uid == "userA", path == "/artifacts/app1/users/userA/tasks/task1"
     * @deny (get) User B cannot read User A's task: auth.uid == "userB", path == "/artifacts/app1/users/userA/tasks/task1"
     * @deny (create) User A cannot create a task under User B's id: auth.uid == "userA", path == "/artifacts/app1/users/userB/tasks/task1"
     * @deny (update) User B cannot update User A's task: auth.uid == "userB", path == "/artifacts/app1/users/userA/tasks/task1"
     * @deny (delete) User B cannot delete User A's task: auth.uid == "userB", path == "/artifacts/app1/users/userA/tasks/task1"
     * @principle Enforces document ownership for all operations.
     */
    match /artifacts/{appId}/users/{userId}/tasks/{taskId} {
      // Read rules
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Write rules
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows read access to projects for all users, but restricts writes.
     * @path /artifacts/{appId}
     * @allow (get) Any user can read project data.
     * @allow (list) Any user can list project data.
     * @deny (create) No one can create projects (explicitly denied for prototyping).
     * @deny (update) No one can update projects (explicitly denied for prototyping).
     * @deny (delete) No one can delete projects (explicitly denied for prototyping).
     * @principle Public read access with restricted writes.
     */
    match /artifacts/{appId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}